public class NaraeNote {

	public static void main(String[] args) {

/*
		 
타입변환 type casting
자동 타입 변환 promotion
 - 짤라도 데이터 손실이 발생하지 않을때
강제 타입 변환 casting
하나의 행에서 alt키를 누르고 down arrow 하면 행이 변경됨
*메인 메소드의 메카니즘?
메인블럭을 찾음(메인블럭을 실행하기 위해서) ==> 호출이라고 함.
-> 메인 실행흐름(메인스레드, 주 thred) 만듦 
-> 끝까지 가면 JVM으로 리턴.
* 코드정렬 / 들여쓰기
ctrl + shift + F
/* System.out.printf();
%d -> data 1개, %%d -> data 2개(?)
스트링은 %s
캐릭터는 %c
		
println은 한줄 띄우기 new line
		
printf에서 한줄 엔터 하고싶으면 %n 하면됨.
printf --> 포메터?
		
	int no1 = 88;
		
	if(no1%2==0) {
		// System.out.println("no1은 짝수입니다.");
		System.out.printf("%d은 %s입니다.%n",no1,"짝수");
	}else {
		// System.out.println("no1은 홀수입니다.");
		System.out.printf("%d는 %s입니다.%n",no1,"홀수");
	}
블록의 뎁스가 너무 깊지않은게 좋음.
->가독성이 떨어짐
refactor -> rename : 클래스파일 이름, 클래스명 모두 다 바꿀 수 있음 쉽게!!★
scanner 입력하고 ctrl + 스페이스바 ==> scanner / java.util. 하면됨.
import java.util.Scanner;
	Scanner console = new Scanner(System.in);
	console.nextInt(); // int eng = console.nextInt();
		// print 로 받으면 옆에서 입력받고
		// println 으로 받으면 한줄 밑에서 입력받게됨.
역슬래쉬t 는 1tap 만큼 떨어뜨려줘 하는것과 같음.
역슬래쉬n 은 엔터와 동일한 기능
for문에서는 i를 사용하고 for 블럭 밖에선 i가 영향을 받지 않는데
while은 while문에서 바뀐대로 i값이 변하니까 계속 초기화 하는 것.
i = i+1; 과 i+=1 이 같은말인 것처럼
total = total + i; 는 total +=i 와 같음
total+=i; // total = i + total;
i+=1 >> +연산 후에 대입하겠다는 뜻
210602 취업특강
%d -> %2d 하면 2자리를 확보한 채 우측정렬됨
%d -> %-10d 하면 좌측에 10자리를 확보한 채 좌측정렬됨.
%5.2f -> 전체자리 5자리수 중 소수점 둘째자리!

0603
클래스는
객체를 찍어내는 틀이면서
데이터의 타입이라는 의미도 가짐


0604
포매터!

sysoutf 템플릿 등록
window - preferences - java - editor - templates


클래스파일이랑 메인메소드파일이 같이 있는거 - 02.OOP[BASIC] - MemberMethodMain.java


dos > java MemberMethodMain 을 실행하면 VM이 만들어지고, 메소드영역(클래스가 적재되는 영역)과 힙영역(객체생성영역)이 생기고.. 
VM이 메인메소드를 찾아.
그러고 관련 있는 모든 클래스파일이 메소드영역에 올라가.
메인 메소드를 찾으면 실행흐름을 준비하고, 메인 메소드를 호출해!


0607
메쏘드 일때만 쓰레드를 그린다.

멤버변수는 class 안에 선언된다.
메인메소드 안에 선언된 변수는 멤버변수가 아님.
멤버변수는 파란글씨로 나옴.

0608
필드는 private으로 하고, 메소드로 사용해야하는 이유
 1) 유지보수가 용이함
 2) 같은 소스를 계속 반복해서 사용해야하는 번거로움을 줄일 수 있음
 3) 재사용성을 높임
 * 메소드는 한가지 기능만 있어야 함
 * 
 * 객체가 구분되려면 필드(멤버변수)가 필요하다.

0609
멤버메소드는 아무런 데이터도 갖고있지 않음
코드 자체만 있음.
멤버메소드 안에서 선언된 변수는 잠깐 만들어졌다가 반환될 때 없어짐.

0610
객체의 확장, 
객체는 독립적인 단위
객체(업무):실제이루어지고있는 업무(주차장)에서 보여지고 구체화되어있는 사물(차)    
객체(프로그램):실제이루어지고있는 업무(주차장)에서 보여지고 구체화되어있는 사물을 메모리의 데이타로 표현한것(차의데이타)
객체간의 관계(포함) - 멤버필드가 참조형이여야 함
왜 캡슐화를 하는지 한번 더!
자기 일은 스스로 하자!!
멤버변수는 private, 메소드로 오픈!


0614

IS A 관계?
vip회원도 일반회원과 같은 속성을 갖고 있어. 더 많은 행위를 갖고 있을 뿐이야!

선택적 상속도 불가능함.


0615
protected 다른놈은 사용 불가.
상속받은 애가 getter, setter없이도 쓸 수 있게 허용한 것.

0616
형변환 연산자는 소괄호로!

실행 시 발생하는 오류를 exception 예외 라고 함.

유지보수때문에 부모를 참조해서 쓰는 것.
자식을 참조하면 의존성이 높아짐.
유지보수가 용이하려면 상속, 재정의, 상위캐스팅

instanceof 는 객체타입을 확인하는데 사용하는 연산자.
부모객체인지 자식객체인지 확인하는데 쓴다.
true, false로 나옴
--> 12번 객체형변환에서 예제 확인 가능
객체 + instanceof + 클래스


0617
추상클래스는 상속과 재정의를 강제함.
모든메소드가 추상클래스(바디가 없는)인게 인터페이스. 완전추상메소드.

이탤릭으로 나오면 추상클래스


0618
추상메소드는 시그니처가 있따...?

인터페이스는 바디가 구현되지 않음.

인터페이스 안에 있는 메소드에는 바디가 없어야돼? 정의가 어긋나?
추상클래스는 5개 메소드가 있따
5개가 추상메소드로 구현되있고 5개는 concrate메소드일때
추상메소드는 스택이 있따고?? 구현된게 없으니까?? 안들려 ㅠㅠ

인터페이스와 추상과 상속의 이점과 같음
 
인터페이스 끼리는 상속받을 수 있다.









*/
		


	}

}
